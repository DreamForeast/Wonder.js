#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#pragma shader_stage(raygen)

#include "../common/camera.glsl"
#include "../common/define_debug.glsl"
#include "random.glsl"
#include "raycommon.glsl"

layout(location = 0) rayPayloadEXT HitPayload path;

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(std140, set = 0, binding = 1) buffer PixelBuffer { vec4 pixels[]; }
pixelBuffer;

layout(std140, set = 0, binding = 2) uniform CommonData {
  uint sampleCount;
  uint totalSampleCount;
  uint pad_0;
  uint pad_1;
}
pushC;

void main() {
  const ivec2 ipos = ivec2(gl_LaunchIDEXT.xy);
  const ivec2 resolution = ivec2(gl_LaunchSizeEXT.xy);

#if DEBUG
  path.debugColor = vec4(1.0, 1.0, 1.0, 1.0);

  const uint sampleCount = 1;

  const uint maxBounceCount = DEBUG_BOUNCE_COUNT;
  const uint minBounceCount = DEBUG_BOUNCE_COUNT;
#else
  const uint sampleCount = pushC.sampleCount;

  const uint maxBounceCount = 5;
  const uint minBounceCount = 2;
#endif

  const uint totalSampleCount = pushC.totalSampleCount;

  // https://www.w3.org/WAI/GL/wiki/Relative_luminance
  const vec3 luminance = vec3(0.2126, 0.7152, 0.0722);

  path.seed = tea(tea(ipos.x, ipos.y), totalSampleCount);

  path.tMax = uCamera.far;

  const uint cullMask = 0xFF;
  vec3 pixelColor = vec3(0.0);

  for (uint ss = 0; ss < sampleCount; ++ss) {
    // const vec2 offset = 1.0 * randInUnitDisk(path.seed);
    const vec2 offset = vec2(0.0);
    const vec2 pixel = vec2(ipos.x + rnd(path.seed), ipos.y + rnd(path.seed));
    const vec2 uv = (pixel / gl_LaunchSizeEXT.xy) * 2.0 - 1.0;

    vec4 origin = uCamera.viewInverse * vec4(offset, 0, 1);
    vec4 target = uCamera.projectionInverse * (vec4(uv.x, uv.y, 1, 1));
    vec4 direction =
        normalize(uCamera.viewInverse *
                  vec4(normalize(target.xyz * 1.0 - vec3(offset, 0)), 0));

    vec3 radiance = vec3(0.0);
    path.throughput = vec3(1.0);
    path.isSpecularBounce = false;
    path.isTerminate = false;

    for (uint bounceIndex = 0; bounceIndex < maxBounceCount; ++bounceIndex) {
      path.bias = vec3(0.0);
      path.t = -1.0;

      path.bounceIndex = bounceIndex;

      traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, cullMask, 0, 0, 0,
                  origin.xyz, uCamera.near, direction.xyz, path.tMax, 0);

      radiance += path.radiance;

      const float t = path.t;
      if (t < 0.0 || path.isTerminate) {
        break;
      }

      // move the ray based on the bsdf direction
      origin = origin + t * direction + vec4(path.bias, 0.0);
      direction = vec4(path.scatterDirection, 0.0);

      // Russian Roulette sampling
      if (bounceIndex >= minBounceCount - 1) {
        float p_rr = 1.0 - dot(path.throughput, luminance);
        if (rnd(path.seed) < p_rr) {
          break;
        }
        path.throughput /= 1.0 - p_rr;
      }
    };

    pixelColor += radiance;
  };

  pixelColor = max(vec3(0), pixelColor);

  const uint pixelIndex = ipos.y * resolution.x + ipos.x;

#if DEBUG
  pixelBuffer.pixels[pixelIndex] = path.debugColor;
#else
  pixelBuffer.pixels[pixelIndex] = vec4(pixelColor, 1.0);
#endif
}